
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async environmentLanguage() : Promise<Result<string, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_language") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentSetLanguage(language: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_set_language", { language }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentTheme() : Promise<Result<string, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_theme") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentSetTheme(theme: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_set_theme", { theme }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentGetProjectSorting() : Promise<Result<string, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_get_project_sorting") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentSetProjectSorting(sorting: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_set_project_sorting", { sorting }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentGetFinishedSetupPages() : Promise<Result<SetupPages[], RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_get_finished_setup_pages") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentFinishedSetupPage(page: SetupPages) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_finished_setup_page", { page }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentClearSetupProcess() : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_clear_setup_process") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentProjects() : Promise<Result<TauriProject[], RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_projects") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentAddProjectWithPicker() : Promise<Result<TauriAddProjectWithPickerResult, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_add_project_with_picker") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentRemoveProject(listVersion: number, index: number, directory: boolean) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_remove_project", { listVersion, index, directory }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentRemoveProjectByPath(path: string, directory: boolean) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_remove_project_by_path", { path, directory }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentCopyProjectForMigration(sourcePath: string) : Promise<Result<string, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_copy_project_for_migration", { sourcePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentSetFavoriteProject(listVersion: number, index: number, favorite: boolean) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_set_favorite_project", { listVersion, index, favorite }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentProjectCreationInformation() : Promise<Result<TauriProjectCreationInformation, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_project_creation_information") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentCheckProjectName(basePath: string, projectName: string) : Promise<Result<TauriProjectDirCheckResult, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_check_project_name", { basePath, projectName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentCreateProject(basePath: string, projectName: string, template: TauriProjectTemplate) : Promise<Result<TauriCreateProjectResult, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_create_project", { basePath, projectName, template }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentRefetchPackages() : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_refetch_packages") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentPackages() : Promise<Result<TauriPackage[], RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_packages") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentRepositoriesInfo() : Promise<Result<TauriRepositoriesInfo, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_repositories_info") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentHideRepository(repository: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_hide_repository", { repository }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentShowRepository(repository: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_show_repository", { repository }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentSetHideLocalUserPackages(value: boolean) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_set_hide_local_user_packages", { value }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentDownloadRepository(url: string, headers: { [key in string]: string }) : Promise<Result<TauriDownloadRepository, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_download_repository", { url, headers }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentAddRepository(url: string, headers: { [key in string]: string }) : Promise<Result<TauriAddRepositoryResult, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_add_repository", { url, headers }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentRemoveRepository(id: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_remove_repository", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentImportRepositoryPick() : Promise<Result<TauriImportRepositoryPickResult, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_import_repository_pick") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentImportDownloadRepositories(channel: string, repositories: TauriRepositoryDescriptor[]) : Promise<Result<AsyncCallResult<number, ([TauriRepositoryDescriptor, TauriDownloadRepository])[]>, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_import_download_repositories", { channel, repositories }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentImportAddRepositories(repositories: TauriRepositoryDescriptor[]) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_import_add_repositories", { repositories }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentExportRepositories() : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_export_repositories") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentClearPackageCache() : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_clear_package_cache") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentGetUserPackages() : Promise<Result<TauriUserPackage[], RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_get_user_packages") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentAddUserPackageWithPicker() : Promise<Result<TauriAddUserPackageWithPickerResult, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_add_user_package_with_picker") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentRemoveUserPackages(path: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_remove_user_packages", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentUnityVersions() : Promise<Result<TauriUnityVersions, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_unity_versions") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentGetSettings() : Promise<Result<TauriEnvironmentSettings, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_get_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentPickUnityHub() : Promise<Result<TauriPickUnityHubResult, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_pick_unity_hub") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentPickUnity() : Promise<Result<TauriPickUnityResult, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_pick_unity") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentPickProjectDefaultPath() : Promise<Result<TauriPickProjectDefaultPathResult, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_pick_project_default_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentPickProjectBackupPath() : Promise<Result<TauriPickProjectBackupPathResult, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_pick_project_backup_path") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentSetShowPrereleasePackages(value: boolean) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_set_show_prerelease_packages", { value }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentSetBackupFormat(backupFormat: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_set_backup_format", { backupFormat }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentSetReleaseChannel(releaseChannel: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_set_release_channel", { releaseChannel }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentSetUseAlcomForVccProtocol(useAlcomForVccProtocol: boolean) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_set_use_alcom_for_vcc_protocol", { useAlcomForVccProtocol }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentGetDefaultUnityArguments() : Promise<Result<string[], RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_get_default_unity_arguments") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async environmentSetDefaultUnityArguments(defaultUnityArguments: string[] | null) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("environment_set_default_unity_arguments", { defaultUnityArguments }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectDetails(projectPath: string) : Promise<Result<TauriProjectDetails, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_details", { projectPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectInstallPackage(projectPath: string, envVersion: number, packageIndex: number) : Promise<Result<TauriPendingProjectChanges, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_install_package", { projectPath, envVersion, packageIndex }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectInstallMultiplePackage(projectPath: string, envVersion: number, packageIndices: number[]) : Promise<Result<TauriPendingProjectChanges, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_install_multiple_package", { projectPath, envVersion, packageIndices }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectUpgradeMultiplePackage(projectPath: string, envVersion: number, packageIndices: number[]) : Promise<Result<TauriPendingProjectChanges, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_upgrade_multiple_package", { projectPath, envVersion, packageIndices }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectResolve(projectPath: string) : Promise<Result<TauriPendingProjectChanges, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_resolve", { projectPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectRemovePackages(projectPath: string, names: string[]) : Promise<Result<TauriPendingProjectChanges, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_remove_packages", { projectPath, names }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectApplyPendingChanges(projectPath: string, changesVersion: number) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_apply_pending_changes", { projectPath, changesVersion }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectClearPendingChanges() : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_clear_pending_changes") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectMigrateProjectTo2022(projectPath: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_migrate_project_to_2022", { projectPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectCallUnityForMigration(channel: string, projectPath: string, unityPath: string) : Promise<Result<AsyncCallResult<string, TauriCallUnityForMigrationResult>, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_call_unity_for_migration", { channel, projectPath, unityPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectMigrateProjectToVpm(projectPath: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_migrate_project_to_vpm", { projectPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectOpenUnity(projectPath: string, unityPath: string) : Promise<Result<boolean, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_open_unity", { projectPath, unityPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectIsUnityLaunching(projectPath: string) : Promise<boolean> {
    return await TAURI_INVOKE("project_is_unity_launching", { projectPath });
},
async projectCreateBackup(channel: string, projectPath: string) : Promise<Result<AsyncCallResult<null, null>, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_create_backup", { channel, projectPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectGetCustomUnityArgs(projectPath: string) : Promise<Result<string[] | null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_get_custom_unity_args", { projectPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectSetCustomUnityArgs(projectPath: string, args: string[] | null) : Promise<Result<boolean, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_set_custom_unity_args", { projectPath, args }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectGetUnityPath(projectPath: string) : Promise<Result<string | null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_get_unity_path", { projectPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async projectSetUnityPath(projectPath: string, unityPath: string | null) : Promise<Result<boolean, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("project_set_unity_path", { projectPath, unityPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async utilOpen(path: string, ifNotExists: OpenOptions) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("util_open", { path, ifNotExists }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async utilOpenUrl(url: string) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("util_open_url", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async utilGetLogEntries() : Promise<LogEntry[]> {
    return await TAURI_INVOKE("util_get_log_entries");
},
async utilGetVersion() : Promise<string> {
    return await TAURI_INVOKE("util_get_version");
},
async utilCheckForUpdate() : Promise<Result<CheckForUpdateResponse | null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("util_check_for_update") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async utilInstallAndUpgrade(version: number) : Promise<Result<null, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("util_install_and_upgrade", { version }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async utilIsBadHostname() : Promise<Result<boolean, RustError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("util_is_bad_hostname") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deepLinkHasAddRepository() : Promise<boolean> {
    return await TAURI_INVOKE("deep_link_has_add_repository");
},
async deepLinkTakeAddRepository() : Promise<AddRepositoryInfo | null> {
    return await TAURI_INVOKE("deep_link_take_add_repository");
},
async deepLinkInstallVcc() : Promise<void> {
    await TAURI_INVOKE("deep_link_install_vcc");
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AddRepositoryInfo = { url: string; headers: { [key in string]: string } }
export type AsyncCallResult<P, R> = { type: "Result"; value: R } | { type: "Started" } | { type: "UnusedProgress"; progress: P }
export type CheckForUpdateResponse = { version: number; current_version: string; latest_version: string; update_description: string | null }
export type LogEntry = { time: string; level: LogLevel; target: string; message: string }
export type LogLevel = "Error" | "Warn" | "Info" | "Debug" | "Trace"
export type OpenOptions = "ErrorIfNotExists" | "CreateFolderIfNotExists" | "OpenParentIfNotExists"
export type RustError = { type: "Unrecoverable"; message: string }
export type SetupPages = "Appearance" | "UnityHub" | "ProjectPath" | "Backups" | "SystemSetting"
export type TauriAddProjectWithPickerResult = "NoFolderSelected" | "InvalidSelection" | "AlreadyAdded" | "Successful"
export type TauriAddRepositoryResult = "BadUrl" | "Success"
export type TauriAddUserPackageWithPickerResult = "NoFolderSelected" | "InvalidSelection" | "AlreadyAdded" | "Successful"
export type TauriBasePackageInfo = { name: string; display_name: string | null; description: string | null; aliases: string[]; version: TauriVersion; unity: [number, number] | null; changelog_url: string | null; vpm_dependencies: string[]; legacy_packages: string[]; is_yanked: boolean }
export type TauriCallUnityForMigrationResult = { type: "ExistsWithNonZero"; status: string } | { type: "FinishedSuccessfully" }
export type TauriConflictInfo = { packages: string[]; unity_conflict: boolean }
export type TauriCreateProjectResult = "AlreadyExists" | "TemplateNotFound" | "Successful"
export type TauriDownloadRepository = { type: "BadUrl" } | { type: "Duplicated" } | { type: "DownloadError"; message: string } | { type: "Success"; value: TauriRemoteRepositoryInfo }
export type TauriEnvironmentSettings = { default_project_path: string; project_backup_path: string; unity_hub: string; unity_paths: ([string, string, boolean])[]; show_prerelease_packages: boolean; backup_format: string; release_channel: string; use_alcom_for_vcc_protocol: boolean; default_unity_arguments: string[] | null }
export type TauriImportRepositoryPickResult = { type: "NoFilePicked" } | { type: "ParsedRepositories"; repositories: TauriRepositoryDescriptor[]; unparsable_lines: string[] }
export type TauriPackage = ({ name: string; display_name: string | null; description: string | null; aliases: string[]; version: TauriVersion; unity: [number, number] | null; changelog_url: string | null; vpm_dependencies: string[]; legacy_packages: string[]; is_yanked: boolean }) & { env_version: number; index: number; source: TauriPackageSource }
export type TauriPackageChange = { InstallNew: TauriBasePackageInfo } | { Remove: TauriRemoveReason }
export type TauriPackageSource = "LocalUser" | { Remote: { id: string; display_name: string } }
export type TauriPendingProjectChanges = { changes_version: number; package_changes: ([string, TauriPackageChange])[]; remove_legacy_files: string[]; remove_legacy_folders: string[]; conflicts: ([string, TauriConflictInfo])[] }
export type TauriPickProjectBackupPathResult = { type: "NoFolderSelected" } | { type: "InvalidSelection" } | { type: "Successful" }
export type TauriPickProjectDefaultPathResult = { type: "NoFolderSelected" } | { type: "InvalidSelection" } | { type: "Successful"; new_path: string }
export type TauriPickUnityHubResult = { type: "NoFolderSelected" } | { type: "InvalidSelection" } | { type: "Successful" }
export type TauriPickUnityResult = "NoFolderSelected" | "InvalidSelection" | "AlreadyAdded" | "Successful"
export type TauriProject = { list_version: number; index: number; name: string; path: string; project_type: TauriProjectType; unity: string; unity_revision: string | null; last_modified: number; created_at: number; favorite: boolean; is_exists: boolean }
export type TauriProjectCreationInformation = { templates: TauriProjectTemplate[]; default_path: string }
export type TauriProjectDetails = { unity: [number, number] | null; unity_str: string | null; unity_revision: string | null; installed_packages: ([string, TauriBasePackageInfo])[]; should_resolve: boolean }
export type TauriProjectDirCheckResult = "InvalidNameForFolderName" | "MayCompatibilityProblem" | "WideChar" | "AlreadyExists" | "Ok"
export type TauriProjectTemplate = { type: "Builtin"; id: string; name: string } | { type: "Custom"; name: string }
export type TauriProjectType = "Unknown" | "LegacySdk2" | "LegacyWorlds" | "LegacyAvatars" | "UpmWorlds" | "UpmAvatars" | "UpmStarter" | "Worlds" | "Avatars" | "VpmStarter"
export type TauriRemoteRepositoryInfo = { display_name: string; id: string; url: string; packages: TauriBasePackageInfo[] }
export type TauriRemoveReason = "Requested" | "Legacy" | "Unused"
export type TauriRepositoriesInfo = { user_repositories: TauriUserRepository[]; hidden_user_repositories: string[]; hide_local_user_packages: boolean; show_prerelease_packages: boolean }
export type TauriRepositoryDescriptor = { url: string; headers: { [key in string]: string } }
export type TauriUnityVersions = { unity_paths: ([string, string, boolean])[]; recommended_version: string; install_recommended_version_link: string }
export type TauriUserPackage = { path: string; package: TauriBasePackageInfo }
export type TauriUserRepository = { id: string; url: string | null; display_name: string }
export type TauriVersion = { major: number; minor: number; patch: number; pre: string; build: string }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: T extends null
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
